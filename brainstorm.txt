LoginView
1) Пользователь вводит желаемое имя, которое затем будет использоваться повсеместно
2) Пользователь выбирать сетевой интерфейс, на основе которого будет выбираться локальная сеть
3) Кнопка Connect (Новичок -> Исследователь)

Новичок -> Исследователь
Новичок начинает принимать TCP-соединения с определённым timeout'ом по порту 53123;
Новичок отправляет multicast в группу 224.0.1.1 по порту 53128;
Каждый вещатель:
    запрашивает TCP-соединение у источника multicast'a по порту 53123;
    отправляет RoomInfoMessage;
    закрывает TCP-соединение (1);
Пока timeout новичка не истек:
    принимает TCP-соединение и приостанавливает приём запросов;
    считывает RoomInfoMessage;
    закрывает TCP-соединение;
    возобновляет приём запросов;
Новичок начинает получать multicast'ы группы 224.0.1.2 по порту 53124;

Примечание 1:
Вещателю нужно будет посылать сигнализирующее сообщение о том, что он хочет закрыть соединение.
Хотя это может оказаться ненужным, если я могу продолжать дочитывать информацию, когда вещатель уже закрыл соединение.
Это надо будет проверить. Проверил, действиетльно, отправлять дополнительное сообщение о закрытии нет
необходимости, поскольку закрытие соединения устанавливает конец потока. Однако это не работает для
ObjectInputStream, для него придётся отправлять DisconnectMessage. Но DisconnectMessage можно не отправлять, если
точно известно, когда нужно прекратить чтение.

Примечание 2:
Возникает проблема следующего характера: если начать получать broadcast'ы сразу, то можно
связаться с одним и тем же узлом лишний раз, а если начать получать broadcast'ы позже, то некоторые узлы
можно пропустить. Проблема неразрешимая в одноранговой сети, поэтому мы этим пренебрежём и будет получать
broadcast'ы в конце.

------------------------------------------------------------------------------------------------

MainMenuView
1) Отображается список существующих комнат, элемент списка содержит
    Владельца
    Название фильма
    Онлайн
2) Кнопка Join (Исследователь -> Зритель)
3) Кнопка Create new

Исследователь -> Зритель
Исследователь прекращает получать multicast'ы группы 224.0.1.2 по порту 53124;
Исследователь начинает принимать фильм;
Исследователь начинает принимать TCP-соединения с определённым timeout'ом по порту 53125;
Исследователь отправляет multicast в группу 224.0.1.3 по порту 53126;
Каждый зритель:
    запрашивает TCP-соединение у источника multicast'a по порту 53125;
    отправляет ViewerInfoMessage;
    считывает StatusMessage;
    если StatusMessage.OK:
        сохраняет TCP-соединение;
    иначе:
        закрывает TCP-соединение;
Пока timeout исследователя не истек:
    принимает TCP-соединение и приостанавливает приём запросов;
    если это TCP-соединение со зрителем из той же комнаты:
        отправляет StatusMessage.OK;
        сохраняет TCP-соединение (1);
    иначе:
        отправляет StatusMessage.WRONG;
        закрывает TCP-соединение;
    возобновляет приём запросов;
Исследователь начинает получать multicast'ы группы 224.0.1.3 по порту 53126;

Примечание 1:
Далее зрители обмениваются друг с другом сообщениями именно по этим сохранённым TCP-соединениям

Примечание 2:
Каждый вещатель является также и зрителем

------------------------------------------------------------------------------------------------

RoomCreatorView
1) Запрос названия фильма
2) Запрос пути к файлу фильма
3) Кнопка Create (Исследователь -> Создатель -> Вещатель)
4) Кнопка Get back

Исследователь -> Новичок
Исследователь прекращает получать multicast'ы группы 224.0.1.2 по порту 53124;

Новичок -> Вещатель
Новичок начинает принимать TCP-соединения с определённым timeout'ом по порту 53127;
Новичок отправляет multicast в группу 224.0.1.2 по порту 53124;
Каждый исследователь:
    запрашивает TCP-соединение у источника multicast'a по порту 53127;
Пока timeout новичка не истек:
    принимает TCP-соединение и приостанавливает приём запросов;
    отправляет RoomInfoMessage;
    закрывает TCP-соединение;
    возобновляет приём запросов;
Новичок начинает получать multicast'ы группы 224.0.1.3 по порту 53126;
Новичок начинает получать multicast'ы группы 224.0.1.1 по порту 53128;
Новичок начинает транслировать фильм;

Примечание 1:
Стоит понимать, что вещатель не особо сильно отличается от зрителя. В отношении чата они вообще ведут
себя совершенно одинаково. Основное различие в том, как будет работать плеер.

------------------------------------------------------------------------------------------------

RoomView
1) Кнопка Exit (Вещатель -> Новичок -> Исследователь или Зритель -> Новичок -> Исследователь)

Вещатель -> Новичок
Вещатель прекращает получать multicast'ы группы 224.0.1.3 по порту 53126;
Вещатель прекращает получать multicast'ы группы 224.0.1.1 по порту 53128;
Вещатель прекращает транслировать фильм;
Вещатель начинает принимать TCP-соединения с определённым timeout'ом по порту 53127;
Вещатель отправляет multicast в группу 224.0.1.2 по порту 53124;
Каждый исследователь:
    запрашивает TCP-соединение у источника multicast'a по порту 53127;
Пока timeout вещателя не истек:
    принимает TCP-соединение и приостанавливает приём запросов;
    отправляет RoomCloseMessage;
    закрывает TCP-соединение;
    возобновляет приём запросов;
Вещатель каждому зрителю:
    отправляет RoomCloseMessage;
    закрывает TCP-соединение;
Каждый зритель:
    прекращает получать multicast'ы группы 224.0.1.3 по порту 53126;
    прекращает принимать фильм;
    закрывает TCP-соединения с другими зрителями;
    Новичок -> Исследователь;

Зритель -> Новичок
Зритель прекращает получать multicast'ы группы 224.0.1.3 по порту 53126;
Зритель прекращает принимать фильм;
Зритель каждому другому зрителю:
    отправляет DisconnectMessage;
    закрывает TCP-соединение;
Каждый другой зритель:
    закрывает TCP-соединение;

------------------------------------------------------------------------------------------------

RoomInfoMessage {
    Тип сообщения
    IP-адресс вещателя
    Имя вещателя
    Название фильма
    Онлайн комнаты
}

ViewerInfoMessage {
    Тип сообщения
    IP-адресс вещателя
}

StatusMessage {
    Тип сообщения
    Статус
}

PauseMessage {

}

TextMessage {
    Тип сообщения
    Имя отправителя
    Текст
}

DisconnectMessage {
    Тип сообщения
}

RoomCloseMessage {
    Тип сообщения
}

Есть следующие состояния:
Новичок
Исследователь
Зритель
Вещатель

Группы:
224.0.1.1 - группа чтобы запросить сведения о комнатах у вещателей
224.0.1.2 - группа чтобы уведомить исследователей о том, что была создана или закрыта комната
224.0.1.3 - группа чтобы подключиться к чату определённой комнаты

Каждый узел находится ровно в одном определённом состоянии, кроме моментов, когда происходит переход из
одного состояния в другое.
Каждое состояния характеризуется определённым набором подсостояний

Исследователь
53123 - порт приёма TCP-соединений
53124 - порт приёма multicast'ов, группа 224.0.1.2

Зритель
53125 - порт приёма TCP-соединений
53126 - порт приёма multicast'ов, группа 224.0.1.3

Вещатель
53125 - порт приёма TCP-соединений
53126 - порт приёма multicast'ов, группа 224.0.1.3

53127 - порт приёма TCP-соединений
53128 - порт приёма multicast'ов, группа 224.0.1.1

Надо попробовать отделить от сервера ту его часть, что ответственна за работу чата. Тогда я смогу переиспользовать
эту часть. Я смогу использовать эту часть и в ViewerServer, и в StreamerServer. Мне останется по-разному реализовать
ту часть, что отвечает за работу плеера и управление комнатой.

Надо смотреть шире. Я на самом деле должен вынести логику не по работе с чатом, а по подключению к сети - комнате.

Хотелось бы вынести всё в один отдельный обработчик типа onMessageReceived
Дальше уже на frontend'e отдельно бы определялось то, как будет оно обработано
Но это невозможно. Поскольку все сообщения перемещаются по единому каналу связи, на frontend могут приходить
системные сообщения, которые ответственны за работу протоколов. Поэтому всё же лучше производить получение и первичную
обработку сообщений на backend'e, а затем триггерить обработчики событий на какие-то конкретные события.
Тогда нужно как можно более граммотно разделить необходимый frontend'у API на интерфейсы, чтобы эти интерфейсы можно
было переиспользовать вместе с их реализацией.

private void roomClosedHandler(RoomCloseEvent event) {
    // Освобождение ресурсов плеера
    embeddedMediaPlayer.controls().stop();
    embeddedMediaPlayer.release();
    mediaPlayerFactory.release();
    // Переход в главное меню
    Controller controller = new MainMenuController(inetAddress, name);
    App.getPrimaryScene().setRoot(controller.getRoot());
}